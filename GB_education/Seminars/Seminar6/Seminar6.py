# Даны два массива чисел. Требуется вывести те элементы
# первого массива (в том порядке, в каком они идут в первом
# массиве), которых нет во втором массиве. Пользователь вводит
# число N - количество элементов в первом массиве, затем N
# чисел - элементы массива. Затем число M - количество
# элементов во втором массиве. Затем элементы второго массива
# Ввод: 
# 7 
# 3 1 3 4 2 4 12
# 6
# 4 15 43 1 15 1 (каждое число вводится с новой строки)
# Вывод:
#  3 3 2 12
# ====================================================
def solution1():
    def fill_array(symbol):
        num = int(input(f"Введите количество элементов массива {symbol} - "))
        lst = []
        for i in range(num):
            lst.append(int(input('Введите элемент: ')))
        return lst
    
    lst_n = fill_array('n')
    lst_m = fill_array('m')
    
    print(lst_n)
    print(lst_m)

    def find_uniq_elements(array1, array2):
        lst_res = []
        for i in range(len(array1)):
            if array1[i] not in array2:
                lst_res.append(array1[i])
        return lst_res
    
    print(find_uniq_elements(lst_n, lst_m))


# solution1()
# ====================================================
# Дан массив, состоящий из целых чисел. Напишите
# программу, которая в данном массиве определит
# количество элементов, у которых два соседних и, при
# этом, оба соседних элемента меньше данного. Сначала
# вводится число N — количество элементов в массиве
# Далее записаны N чисел — элементы массива. Массив
# состоит из целых чисел.
# Ввод: 
# 5 
# 1 2 3 4 5
# 5
# 1 5 1 5 1
# Вывод: 
# 0 
# 2
# (каждое число вводится с новой строки)
# ====================================================
def solution2():
    def fill_array(symbol):
        num = int(input(f"Введите количество элементов массива {symbol} - "))
        lst = []
        for i in range(num):
            lst.append(int(input('Введите элемент: ')))
        return lst
    
    lst_n = fill_array('n')
    print(lst_n)

    def count_local_max(array):
        count = 0
        for i in range(1, len(array)-1):
            if array[i] > array[i-1] and array[i] > array[i+1]:
                count += 1
        return count
    
    print(count_local_max(lst_n))
    
# solution2()
# ====================================================
# Задача №43. Решение в группах
# Дан список чисел. Посчитайте, сколько в нем пар
# элементов, равных друг другу. Считается, что любые
# два элемента, равные друг другу образуют одну пару,
# которую необходимо посчитать. Вводится список
# чисел. Все числа списка находятся на разных
# строках.
# Ввод:         Вывод:
# 1 2 3 2 3       2
# ====================================================
def solution3():
    def fill_array(symbol):
        num = int(input(f"Введите количество элементов массива {symbol} - "))
        lst = []
        for i in range(num):
            lst.append(int(input('Введите элемент: ')))
        return lst
    
    lst_n = fill_array('n')
    print(lst_n)

    def count_similar_elements(lst):
        count = 0
        for i in range(len(lst)):
            for j in range(i, len(lst)):
                if lst[i] == lst[j]:
                    count += 1
        return count
    
    print(count_similar_elements(lst_n))

# solution3()
# ====================================================
# Задача №45. Решение в группах
# Два различных натуральных числа n и m называются
# дружественными, если сумма делителей числа n
# (включая 1, но исключая само n) равна числу m и
# наоборот. Например, 220 и 284 – дружественные числа.
# По данному числу k выведите все пары дружественных
# чисел, каждое из которых не превосходит k. Программа
# получает на вход одно натуральное число k, не
# превосходящее 10**5
# . Программа должна вывести все
# пары дружественных чисел, каждое из которых не
# превосходит k. Пары необходимо выводить по одной в
# строке, разделяя пробелами. Каждая пара должна быть
# выведена только один раз (перестановка чисел новую
# пару не дает).
# Ввод: Вывод:
# 300 220 284

# ====================================================
def solution4():
    def find_freindly_numbers(n):
        sum = 0
        num1 = 0
        num2 = 0
        lst = []
        for i in range(1, n+1):
            for j in range(1, i):
                if i/j == i//j:
                    sum += j
            lst.append([i,sum])
            sum = 0
        return lst
    



    num = int(input('введите число: '))
    print(find_freindly_numbers(num))
    freindly_numbers = find_freindly_numbers(num)
    for i in range(1, num):
        for j in range(i+1, num):
            if freindly_numbers[i][0] == freindly_numbers[j][1] and freindly_numbers[i][1] == freindly_numbers[j][0]:
                print(freindly_numbers[i][0], freindly_numbers[j][0])
                # pass

    
# solution4()
# =================================================== 
def solution4_1():

    lst = [(i, sum([j for j in range(1, i) if i%j == 0 ])) for i in range(1, 300)]
    for i in range(len(lst)):
        for j in range(i, len(lst)):
            if lst[i][1] == lst[j][0] and lst[i][0] == lst[j][1] and lst[i][0] !=lst[j][1]:
                print(lst[i]) 
    
    
solution4_1()
# ============================================================================
# На входе имеем список строк разной длины.
# Необходимо написать функцию all_eq(lst), которая вернет новый список из строк одинаковой длины.
# Длину итоговой строки определяем исходя из самой большой из них.
# Если конкретная строка короче самой длинной, дополнить ее нижними подчеркиваниями с правого края до требуемого количества символов.
# Расположение элементов начального списка не менять.
# =====================================================================
def solution5():
    cities = ['Moscow', 'Berlin', 'Minsk', 'Mongolia', 'Kanada']
    max_cities = max(cities, key=len)
    lst = [i if len(i) == len(max_cities) else i + (len(max_cities) - len(i))*"_" for i in cities]
    print(lst)
solution5()

# =====================================================================